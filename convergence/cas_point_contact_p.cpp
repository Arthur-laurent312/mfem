// COMPILE WITH: MAKE CAS_POINT_CONTACT
//
//CAS TEST AVEC SOLUTION ANALYTIQUE. PLAQUE 2D AVEC POINT DE CONTACT EN (0,0).
//CALCUL DE LA DÉFORMATION EN ÉLASTICITÉ LINÉAIRE. 
//VERSION PARALLÈLE

//REF: HTTP://E6.IJS.SI/MEDUSA/WIKI/INDEX.PHP/POINT_CONTACT

#INCLUDE "MFEM.HPP"
#INCLUDE <FSTREAM>
#INCLUDE <IOSTREAM>

USING NAMESPACE STD;
USING NAMESPACE MFEM;

STATIC CONSTEXPR DOUBLE FORCE = -1.;
STATIC CONSTEXPR DOUBLE E = 1000.;	//MODULE DE YOUNG
STATIC CONSTEXPR DOUBLE NU = 0.25;	//COEF DE POISSON
STATIC CONSTEXPR DOUBLE LAMBDA = E*NU/((1.+NU)*(1.-2.*NU));
STATIC CONSTEXPR DOUBLE MU = E/(2.*(1.+NU));	//COEF DE LAMÉ

VOID SOL_EXACT(CONST VECTOR &, VECTOR &);
DOUBLE UX_EXACT(CONST VECTOR &);
DOUBLE UY_EXACT(CONST VECTOR &);
VOID GRAD_EXACT(CONST VECTOR &, DENSEMATRIX &);
VOID GRADEXACT_X(CONST VECTOR &, VECTOR &);
VOID GRADEXACT_Y(CONST VECTOR &, VECTOR &);

DOUBLE COMPUTEENERGYNORM(GRIDFUNCTION &,
			 COEFFICIENT &, COEFFICIENT &);

VOID ELASTICY_MAT(ELEMENTTRANSFORMATION &,CONST INTEGRATIONPOINT &, 
		  INT, COEFFICIENT &, COEFFICIENT &, DENSEMATRIX &);

DOUBLE COMPUTEH1NORM(GRIDFUNCTION &);

VOID COMPUTESTRESS(ELEMENTTRANSFORMATION &,CONST INTEGRATIONPOINT &,
		   GRIDFUNCTION &, INT,  VECTOR &);

INT MAIN(INT ARGC, CHAR *ARGV[])
{

//   // INITIALIZE MPI.
//   INT NUM_PROCS, MYID;
//   MPI_INIT(&ARGC, &ARGV);
//   MPI_COMM_SIZE(MPI_COMM_WORLD, &NUM_PROCS);
//   MPI_COMM_RANK(MPI_COMM_WORLD, &MYID);
//   // PARSE COMMAND-LINE OPTIONS.
//   INT ORDER=2;
//   CONST CHAR *MESH_FILE = "CARRE.MSH";
//   BOOL STATIC_COND = FALSE;
//   BOOL AMG_ELAST = 0;
//   BOOL REORDER_SPACE = FALSE;
//   BOOL SOLVER=TRUE;
//   INT REF_LEVELS = 8;
//   OPTIONSPARSER ARGS(ARGC, ARGV);
//   ARGS.ADDOPTION(&MESH_FILE, "-M", "--MESH",
// 		 "MESH FILE TO USE.");
//   ARGS.ADDOPTION(&ORDER, "-O", "--ORDER",
// 		 "FINITE ELEMENT ORDER (POLYNOMIAL DEGREE).");
//   ARGS.ADDOPTION(&AMG_ELAST, "-ELAST", "--AMG-FOR-ELASTICITY", "-SYS",
// 		 "--AMG-FOR-SYSTEMS",
// 		 "USE THE SPECIAL AMG ELASTICITY SOLVER (GM/LN APPROACHES), "
// 		 "OR STANDARD AMG FOR SYSTEMS (UNKNOWN APPROACH).");
//   ARGS.ADDOPTION(&STATIC_COND, "-SC", "--STATIC-CONDENSATION", "-NO-SC",
// 		 "--NO-STATIC-CONDENSATION", "ENABLE STATIC CONDENSATION.");
//   ARGS.ADDOPTION(&REORDER_SPACE, "-NODES", "--BY-NODES", "-VDIM", "--BY-VDIM",
// 		 "USE BYNODES ORDERING OF VECTOR SPACE INSTEAD OF BYVDIM");
//   ARGS.ADDOPTION(&SOLVER, "-SOL", "--ITÉRATIF", "-DIRECT",
//        		 "--SOLVER ITÉRATIF", "SOLVER DIRECT.");
//   ARGS.ADDOPTION(&REF_LEVELS, "-REF", "--NUM_REF", "NOMBRE DE RAFINEMENT DE MAILLAGE");

//   ARGS.PARSE();
//   IF (!ARGS.GOOD())
//     {
//       IF (MYID == 0)
// 	{
// 	  ARGS.PRINTUSAGE(COUT);
// 	}
//       MPI_FINALIZE();
//       RETURN 1;
//     }
//   IF (MYID == 0)
//     {
//       ARGS.PRINTOPTIONS(COUT);
//     }

//   //LECTURE DU MALLIAGE
//   MESH *MESH = NEW MESH(MESH_FILE, 1, 1);
//   INT DIM = MESH->DIMENSION();

//   //  REFINE THE MESH TO INCREASE THE RESOLUTION. IN THIS EXAMPLE WE DO
//   //    'REF_LEVELS' OF UNIFORM REFINEMENT. WE CHOOSE 'REF_LEVELS' TO BE THE
//   //    LARGEST NUMBER THAT GIVES A FINAL MESH WITH NO MORE THAN 5,000
//   //    ELEMENTS.
//   //   INT REF_LEVELS = (INT)FLOOR(LOG(5000./MESH->GETNE())/LOG(2.)/DIM);

//   FOR (INT L = 0; L < REF_LEVELS; L++)
//     {
//       MESH->UNIFORMREFINEMENT();
//     }

//   //DEFINE PARALLEL MESH BY A PARTITIONING OF THE SERIAL MESH.
//   PARMESH *PMESH = NEW PARMESH(MPI_COMM_WORLD, *MESH);
//   /*
//     INT PAR_REF_LEVELS = 1;
//     FOR (INT L = 0; L < PAR_REF_LEVELS; L++)
//     {
//     PMESH->UNIFORMREFINEMENT();
//     }
//   */
//   //  DEFINE A FINITE ELEMENT SPACE ON THE MESH. HERE WE USE VECTOR FINITE
//   //    ELEMENTS, I.E. DIM COPIES OF A SCALAR FINITE ELEMENT SPACE. THE VECTOR
//   //    DIMENSION IS SPECIFIED BY THE LAST ARGUMENT OF THE FINITEELEMENTSPACE
//   //    CONSTRUCTOR. FOR NURBS MESHES, WE USE THE (DEGREE ELEVATED) NURBS SPACE
//   //    ASSOCIATED WITH THE MESH NODES.
//   FINITEELEMENTCOLLECTION *FEC;
//   PARFINITEELEMENTSPACE *FESPACE;
//   CONST BOOL USE_NODAL_FESPACE = PMESH->NURBSEXT && !AMG_ELAST;
//   IF (USE_NODAL_FESPACE)
//     {
//       FEC = NULL;
//       FESPACE = (PARFINITEELEMENTSPACE *)PMESH->GETNODES()->FESPACE();
//     }
//   ELSE
//     {
//       FEC = NEW H1_FECOLLECTION(ORDER, DIM);
//       IF (REORDER_SPACE)
// 	{
// 	  FESPACE = NEW PARFINITEELEMENTSPACE(PMESH, FEC, DIM, ORDERING::BYNODES);
// 	}
//       ELSE
// 	{
// 	  FESPACE = NEW PARFINITEELEMENTSPACE(PMESH, FEC, DIM, ORDERING::BYVDIM);
// 	}
//     }
//   HYPRE_INT SIZE = FESPACE->GLOBALTRUEVSIZE();
//   IF (MYID == 0)
//     {
//       COUT << "NUMBER OF FINITE ELEMENT UNKNOWNS: " << SIZE << ENDL
//            << "ASSEMBLING: " << FLUSH;
//     }

//   // DETERMINE THE LIST OF TRUE (I.E. CONFORMING) ESSENTIAL BOUNDARY DOFS.
//   //    IN THIS EXAMPLE, THE BOUNDARY CONDITIONS ARE DEFINED BY MARKING ONLY
//   //    BOUNDARY ATTRIBUTE 1 FROM THE MESH AS ESSENTIAL AND CONVERTING IT TO A
//   //    LIST OF TRUE DOFS.


//   // LIST OF TRUE DOFS : DEFINE (HERE) DIRICHLET CONDITIONS
//   ARRAY<INT> ESS_TDOF_LIST;
//   ARRAY<INT> ESS_BDR(PMESH->BDR_ATTRIBUTES.MAX());
//   ESS_BDR = 1;		//ON SÉLECTIONNE TOUS LES BORDS
//   FESPACE->GETESSENTIALTRUEDOFS(ESS_BDR, ESS_TDOF_LIST);

//   // SET UP THE LINEAR FORM B(.) WHICH CORRESPONDS TO THE RIGHT-HAND SIDE OF
//   //    THE FEM LINEAR SYSTEM. IN THIS CASE, B_I EQUALS THE BOUNDARY INTEGRAL
//   //    OF F*PHI_I WHERE F REPRESENTS A "PULL DOWN" FORCE ON THE NEUMANN PART
//   //    OF THE BOUNDARY AND PHI_I ARE THE BASIS FUNCTIONS IN THE FINITE ELEMENT
//   //    FESPACE. THE FORCE IS DEFINED BY THE VECTORARRAYCOEFFICIENT OBJECT F,
//   //    WHICH IS A VECTOR OF COEFFICIENT OBJECTS. THE FACT THAT F IS NON-ZERO
//   //    ON BOUNDARY ATTRIBUTE 2 IS INDICATED BY THE USE OF PIECE-WISE CONSTANTS
//   //    COEFFICIENT FOR ITS LAST COMPONENT.

//   VECTORARRAYCOEFFICIENT F(DIM);
//   FOR (INT I = 0; I < DIM-1; I++)
//     {
//       F.SET(I, NEW CONSTANTCOEFFICIENT(0.0));
//     }

//   PARLINEARFORM *B = NEW PARLINEARFORM(FESPACE);
//   B->ASSEMBLE();
//   IF (MYID == 0)
//     {
//       COUT << "R.H.S. ... " << FLUSH;
//     }

//   // DEFINE THE SOLUTION VECTOR X AS A FINITE ELEMENT GRID FUNCTION
//   //    CORRESPONDING TO FESPACE. INITIALIZE X WITH INITIAL GUESS OF ZERO,
//   //    WHICH SATISFIES THE BOUNDARY CONDITIONS.
//   PARGRIDFUNCTION X(FESPACE);
//   VECTORFUNCTIONCOEFFICIENT BOUNDARY_DIRICHLET_COEF(DIM, SOL_EXACT);
//   X = 0.0;
//   // TO USE IF THERE ARE DIFFERENT DIRICHLET CONDITIONS.
//   // BEWARE, THE VALUES OF DIRICHLET BOUNDARY CONDITIONS ARE SET HERE !
//   //PROJÈTE SOLUTION EXACTE SUR LES BORDS
//   X.PROJECTBDRCOEFFICIENT(BOUNDARY_DIRICHLET_COEF, ESS_BDR);	

//   // SET UP THE BILINEAR FORM A(.,.) ON THE FINITE ELEMENT SPACE
//   //    CORRESPONDING TO THE LINEAR ELASTICITY INTEGRATOR WITH PIECE-WISE
//   //    CONSTANTS COEFFICIENT LAMBDA AND MU.

//   CONSTANTCOEFFICIENT MU_FUNC(MU);
//   CONSTANTCOEFFICIENT LAMBDA_FUNC(LAMBDA);

//   PARBILINEARFORM *A = NEW PARBILINEARFORM(FESPACE);
//   BILINEARFORMINTEGRATOR *INTEG = NEW ELASTICITYINTEGRATOR(LAMBDA_FUNC, MU_FUNC);
//   A->ADDDOMAININTEGRATOR(INTEG);

//   // ASSEMBLE THE PARALLEL BILINEAR FORM AND THE CORRESPONDING LINEAR
//   //     SYSTEM, APPLYING ANY NECESSARY TRANSFORMATIONS SUCH AS: PARALLEL
//   //     ASSEMBLY, ELIMINATING BOUNDARY CONDITIONS, APPLYING CONFORMING
//   //     CONSTRAINTS FOR NON-CONFORMING AMR, STATIC CONDENSATION, ETC.
//   IF (MYID == 0) { COUT << "MATRIX ... " << FLUSH; }
//   IF (STATIC_COND) { A->ENABLESTATICCONDENSATION(); }
//   A->ASSEMBLE();

//   HYPREPARMATRIX A;
//   VECTOR B, X;

//   A->FORMLINEARSYSTEM(ESS_TDOF_LIST, X, *B, A, X, B);
//   IF (MYID == 0)
//     {
//       COUT << "DONE." << ENDL;
//       COUT << "SIZE OF LINEAR SYSTEM: " << A.GETGLOBALNUMROWS() << ENDL;
//     }

//   // 13. DEFINE AND APPLY A PARALLEL PCG SOLVER FOR A X = B WITH THE BOOMERAMG
//   //     PRECONDITIONER FROM HYPRE.

//   IF(SOLVER){
//     HYPREBOOMERAMG *AMG = NEW HYPREBOOMERAMG(A);
//     IF (AMG_ELAST && !A->STATICCONDENSATIONISENABLED())
//       {
// 	AMG->SETELASTICITYOPTIONS(FESPACE);
//       }
//     ELSE
//       {
// 	AMG->SETSYSTEMSOPTIONS(DIM, REORDER_SPACE);
//       }
//     HYPREPCG *PCG = NEW HYPREPCG(A);
//     PCG->SETTOL(1E-20);
//     PCG->SETMAXITER(5000);
//     PCG->SETPRINTLEVEL(2);
//     PCG->SETPRECONDITIONER(*AMG);
//     PCG->MULT(B, X);
//     DELETE PCG;
//     DELETE AMG;
//   }
//   ELSE{
//     COUT<<"SOLVER DIRECT NON IMPLÉMENTÉ"<<ENDL;
//   }   


//   // 12. RECOVER THE SOLUTION AS A FINITE ELEMENT GRID FUNCTION.
//   A->RECOVERFEMSOLUTION(X, *B, X);


//   // 13. FOR NON-NURBS MESHES, MAKE THE MESH CURVED BASED ON THE FINITE ELEMENT
//   //     SPACE. THIS MEANS THAT WE DEFINE THE MESH ELEMENTS THROUGH A FESPACE
//   //     BASED TRANSFORMATION OF THE REFERENCE ELEMENT. THIS ALLOWS US TO SAVE
//   //     THE DISPLACED MESH AS A CURVED MESH WHEN USING HIGH-ORDER FINITE
//   //     ELEMENT DISPLACEMENT FIELD. WE ASSUME THAT THE INITIAL MESH (READ FROM
//   //     THE FILE) IS NOT HIGHER ORDER CURVED MESH C<OMPARED TO THE CHOSEN FE
//   //     SPACE.
//   IF (!USE_NODAL_FESPACE)
//     {
//       PMESH->SETNODALFESPACE(FESPACE);
//     }

//   // COMPUTE ERRORS
//   DOUBLE ENER_ERROR = COMPUTEENERGYNORM(X, LAMBDA_FUNC, MU_FUNC);
//   VECTORFUNCTIONCOEFFICIENT SOL_EXACT_COEF(DIM, SOL_EXACT);
//   DOUBLE L2_ERROR = X.COMPUTEL2ERROR(SOL_EXACT_COEF);
//   DOUBLE H1_ERROR = COMPUTEH1NORM(X);
//   IF (MYID == 0)
//     {
//       COUT<<"ERREUR EN NORME L2: "<<L2_ERROR<<ENDL;
//       COUT<<"ERREUR EN NORME ÉNERGIE: "<<ENER_ERROR<<ENDL;
//       COUT<<"ERREUR EN NORME H1: "<<H1_ERROR<<ENDL;  
//       COUT<<"TAILLE DE MAILLE: "<<H<<ENDL;    
//       COUT << "NUMBERS OF ELEMENTS: " << PMESH->GETNE() <<ENDL;
//     }
//   //  FREE THE USED MEMORY.
//   DELETE A;
//   DELETE B;
//   IF (FEC)
//     {
//       DELETE FEC;
//     }
//   DELETE MESH;
//   DELETE PMESH;

//   MPI_FINALIZE();
//   /*
//   //SAVE IN PRAVIEW FORMAT
//   IF (REF1==0){
//   PARGRIDFUNCTION DIFF(FESPACE);
//   PARGRIDFUNCTION EX1(FESPACE);
//   DIFF.PROJECTCOEFFICIENT(SOL_EXACT_COEF);
//   EX1.PROJECTCOEFFICIENT(SOL_EXACT_COEF);
//   DIFF-= X;
 
//   PARAVIEWDATACOLLECTION PARAVIEW_DC("EXAMPLE2", MESH);
//   PARAVIEW_DC.SETPREFIXPATH("PARAVIEW");
//   PARAVIEW_DC.SETLEVELSOFDETAIL(ORDER+1);
//   PARAVIEW_DC.SETCYCLE(0);
//   PARAVIEW_DC.SETDATAFORMAT(VTKFORMAT::BINARY);
//   PARAVIEW_DC.SETHIGHORDEROUTPUT(TRUE);
//   PARAVIEW_DC.SETTIME(0.0); // SET THE TIME
//   PARAVIEW_DC.REGISTERFIELD("NUMERICAL_SOLUTION",&X);
//   PARAVIEW_DC.REGISTERFIELD("DIFF-EXACT_SOLUTION",&DIFF);
//   PARAVIEW_DC.REGISTERFIELD("EXACT_SOLUTION",&EX1);
//   PARAVIEW_DC.SAVE();	
//   }
//   */

//   RETURN 0;
// }

// //===================== SOLUTION EXACTE =====================
// VOID SOL_EXACT(CONST VECTOR &X, VECTOR &U)
// {
//   DOUBLE R2 = X(1)*X(1)+X(0)*X(0);
//   DOUBLE PI = M_PI;
//   U(0) = -FORCE/(4*PI*MU)*(2*X(0)*X(1)/R2 + 2*MU/(LAMBDA+MU)*ATAN2(X(1),X(0)));
//   U(1) = -FORCE/(4*PI*MU)*((X(1)*X(1)-X(0)*X(0))/R2 - 
// 			   (LAMBDA+2*MU)*LOG(R2)/(LAMBDA+MU));
// }
// DOUBLE UX_EXACT(CONST VECTOR &X)
// {
//   DOUBLE R2 = X(1)*X(1)+X(0)*X(0);
//   DOUBLE PI = M_PI;
//   RETURN -FORCE/(4*PI*MU)*(2*X(0)*X(1)/R2 + 2*MU/(LAMBDA+MU)*ATAN2(X(1),X(0)));
// }

// DOUBLE UY_EXACT(CONST VECTOR &X)
// {
//   DOUBLE R2 = X(1)*X(1)+X(0)*X(0);
//   DOUBLE PI = M_PI;
//   RETURN -FORCE/(4*PI*MU)*((X(1)*X(1)-X(0)*X(0))/R2 - 
// 			   (LAMBDA+2*MU)*LOG(R2)/(LAMBDA+MU));
// }
// //===================== GRAD EXACTE =====================
// VOID GRAD_EXACT(CONST VECTOR &X, DENSEMATRIX &GRAD)
// {
//   DOUBLE R2 = X(1)*X(1)+X(0)*X(0);
//   DOUBLE PI = M_PI;

//   GRAD(0,0) = -FORCE/(4*PI*MU)*(2*X(1)*(X(1)*X(1)-X(0)*X(0))/(R2*R2)-2*MU/(LAMBDA+MU)*X(1)/R2);
//   GRAD(0,1) = -FORCE/(4*PI*MU)*(2*X(0)*(X(0)*X(0)-X(1)*X(1))/(R2*R2) + 2*MU/(LAMBDA+MU)*X(0)/R2);
//   GRAD(1,1) = -FORCE/(4*PI*MU)*(4*X(1)*X(0)*X(0)/(R2*R2) - 
// 				(LAMBDA+2*MU)/(LAMBDA+MU)*2*X(1)/R2);
//   GRAD(1,0) = -FORCE/(4*PI*MU)*(-4*X(1)*X(1)*X(0)/(R2*R2) - 
// 				(LAMBDA+2*MU)/(LAMBDA+MU)*2*X(0)/R2);
// }
// VOID GRADEXACT_X(CONST VECTOR &X, VECTOR &GRAD)
// {
//   DOUBLE R2 = X(1)*X(1)+X(0)*X(0);
//   DOUBLE PI = M_PI;
//   GRAD(0) = -FORCE/(4*PI*MU)*(2*X(1)*(X(1)*X(1)-X(0)*X(0))/(R2*R2)-2*MU/(LAMBDA+MU)*X(1)/R2);
//   GRAD(1) = -FORCE/(4*PI*MU)*(2*X(0)*(X(0)*X(0)-X(1)*X(1))/(R2*R2) + 2*MU/(LAMBDA+MU)*X(0)/R2);
// }
// VOID GRADEXACT_Y(CONST VECTOR &X, VECTOR &GRAD)
// {
//   DOUBLE R2 = X(1)*X(1)+X(0)*X(0);
//   DOUBLE PI = M_PI;
//   GRAD(1) = -FORCE/(4*PI*MU)*(4*X(1)*X(0)*X(0)/(R2*R2) - 
// 			      (LAMBDA+2*MU)/(LAMBDA+MU)*2*X(1)/R2);
//   GRAD(0) = -FORCE/(4*PI*MU)*(-4*X(1)*X(1)*X(0)/(R2*R2) - 
// 			      (LAMBDA+2*MU)/(LAMBDA+MU)*2*X(0)/R2);
// }

// //===================== ERREUR EN NORME H1 =====================
// DOUBLE COMPUTEH1NORM(GRIDFUNCTION &X){
//   FINITEELEMENTSPACE *FES = X.FESPACE();
//   INT DIM = FES->GETMESH()->SPACEDIMENSION();

//   MATRIXFUNCTIONCOEFFICIENT GRAD_EXACT_COEF (DIM, GRAD_EXACT);
//   ELEMENTTRANSFORMATION *TRANS;
//   DENSEMATRIX GRAD, GRADH;
//   DOUBLE ERROR = 0.0;
//   ARRAY<INT> UDOFS;
//   FOR (INT I = 0; I < FES->GETNE() ; I++)
//     {
//       CONST FINITEELEMENT *FE = FES->GETFE(I);
//       CONST INT ORDER = 2*FE->GETORDER() + 3;   //<----------
//       CONST INTEGRATIONRULE *IR = &(INTRULES.GET(FE->GETGEOMTYPE(), ORDER));
//       TRANS = FES->GETELEMENTTRANSFORMATION(I);
//       CONST INT DOF = FE->GETDOF();
//       CONST INT TDIM = DIM*(DIM+1)/2; // NUM. ENTRIES IN A SYMMETRIC TENSOR

//       DENSEMATRIX DSHAPE(DOF, DIM);
//       DENSEMATRIX GH(DIM, DIM),GRADH (DIM, DIM),GRAD(DIM,DIM);
//       FES->GETELEMENTVDOFS(I, UDOFS);
//       DENSEMATRIX LOC_DATA(DOF, DIM);

//       FOR (INT S=0 ; S<DIM ; S++)
// 	{
// 	  ARRAY<INT> UDOFS_TMP(DOF);
// 	  UDOFS_TMP = 0.;
// 	  FOR(INT J=0 ; J<DOF ; J++){
// 	    UDOFS_TMP[J] = UDOFS[J+DOF*S];}

// 	  VECTOR LOC_DATA_TMP;
// 	  X.GETSUBVECTOR(UDOFS_TMP, LOC_DATA_TMP);

// 	  FOR (INT J=0 ; J<DOF ; J++)
// 	    LOC_DATA(J,S) = LOC_DATA_TMP(J);
// 	}
//       FOR (INT J = 0; J < IR->GETNPOINTS(); J++)
// 	{
// 	  CONST INTEGRATIONPOINT &IP = IR->INTPOINT(J);
// 	  TRANS->SETINTPOINT(&IP);
// 	  DOUBLE W = TRANS->WEIGHT() * IP.WEIGHT;
// 	  FE->CALCDSHAPE(IP, DSHAPE);
// 	  MULTATB(LOC_DATA, DSHAPE, GH);
// 	  MULT(GH, TRANS->INVERSEJACOBIAN(), GRADH);
// 	  GRAD_EXACT_COEF.EVAL(GRAD,*TRANS,IP);
// 	  GRAD -= GRADH;
// 	  ERROR += W * GRAD.FNORM2();
// 	}			
//     }
//   RETURN (ERROR < 0.0) ? -SQRT(-ERROR) : SQRT(ERROR);
// }

// //==============ERREUR EN NORME ENERGIE ===================
// DOUBLE COMPUTEENERGYNORM(GRIDFUNCTION &X,
// 			 COEFFICIENT &LAMBDAH, COEFFICIENT &MUH)
// {
//   FINITEELEMENTSPACE *FES = X.FESPACE();
//   INT DIM = FES->GETMESH()->SPACEDIMENSION();
//   VECTORFUNCTIONCOEFFICIENT SOL_EXACT_COEF (DIM, SOL_EXACT);
//   GRIDFUNCTION EX(FES);
//   EX.PROJECTCOEFFICIENT(SOL_EXACT_COEF);
  
//   CONSTANTCOEFFICIENT LAMBDA_FUNC(LAMBDA);
//   CONSTANTCOEFFICIENT MU_FUNC(MU);
//   ELEMENTTRANSFORMATION *TRANS;

//   DOUBLE ENERGY = 0.0;
//   FOR (INT I = 0; I < FES->GETNE() ; I++)
//     {
//       CONST FINITEELEMENT *FE = FES->GETFE(I);
//       CONST INT ORDER = 2*FE->GETORDER()+3; // <----------
//       CONST INTEGRATIONRULE *IR = &INTRULES.GET(FE->GETGEOMTYPE(), ORDER);
//       CONST INT DOF = FE->GETDOF();
//       CONST INT TDIM = DIM*(DIM+1)/2; // NUM. ENTRIES IN A SYMMETRIC TENSOR
//       TRANS = FES->GETELEMENTTRANSFORMATION(I);
//       VECTOR STRESSH(TDIM), STRAINH(TDIM);	//APPROCHÉ
//       VECTOR STRESS(TDIM), STRAIN(TDIM);	//EXACTE
//       DENSEMATRIX C,CH;
//       FOR (INT J = 0; J < IR->GETNPOINTS(); J++)
// 	{
// 	  CONST INTEGRATIONPOINT &IP = IR->INTPOINT(J);
// 	  TRANS->SETINTPOINT(&IP);
// 	  DOUBLE W = TRANS->WEIGHT() * IP.WEIGHT;

// 	  COMPUTESTRESS(*TRANS, IP, X, I, STRESSH);
// 	  COMPUTESTRESS(*TRANS, IP, EX, I, STRESS);

// 	  //======= STRESS VECTORS ========
// 	  ELASTICY_MAT(*TRANS,IP,DIM,LAMBDA_FUNC,MU_FUNC,C);
// 	  ELASTICY_MAT(*TRANS,IP,DIM,LAMBDAH,MUH,CH);

// 	  CH.MULT(STRESSH,STRAINH);	//APPROX
// 	  C.MULT(STRESS,STRAIN);	//EXACTE

// 	  STRAINH -= STRAIN;
// 	  STRESSH -= STRESS;

// 	  DOUBLE PDC=0.0;
// 	  FOR (INT K = 0; K< DIM; K++)
// 	    PDC += STRAINH(K)*STRESSH(K);

// 	  FOR (INT K = DIM; K < DIM*(DIM+1)/2; K++)
// 	    PDC += 2*STRAINH(K)*STRESSH(K);

// 	  ENERGY += W * PDC;
// 	}
//     }
//   MPI_REDUCE(&ENERGY_LOCAL, &ENERGY_GLOBAL, 1, MPI_DOUBLE, MPI_SUM, 0,
// 	     MPI_COMM_WORLD);
//   RETURN (ENERGY_GLOBAL < 0.0) ? -SQRT(-ENERGY_GLOBAL) : SQRT(ENERGY_GLOBAL);
// }

// //===================== MATRICE ÉLASTICITÉ =====================
// VOID ELASTICY_MAT(ELEMENTTRANSFORMATION &T,CONST INTEGRATIONPOINT &IP, 
// 		  INT DIM, COEFFICIENT &LAMBDA, COEFFICIENT &MU_FUNC, DENSEMATRIX &C){
//   DOUBLE M = MU_FUNC.EVAL(T, IP);
//   DOUBLE L = LAMBDA.EVAL(T, IP);

//   C.SETSIZE(DIM*(DIM+1)/2,DIM*(DIM+1)/2);
//   C = 0.;
//   FOR (INT K = 0; K< DIM; K++)
//     {
//       // EXTRA-DIAGONAL TERMS
//       FOR (INT L = 0; L< DIM; L++)
// 	C(K,L) = L;
//       // DIAGONAL TERMS
//       C(K,K) = L+2*M;
//     }
//   // DIAGONAL TERMS
//   FOR (INT K = DIM; K < DIM*(DIM+1)/2; K++)
//     C(K,K) = M;
// }

// //===================== DÉFORMATION =====================
// VOID COMPUTESTRESS(ELEMENTTRANSFORMATION &T,CONST INTEGRATIONPOINT &IP,
// 		   GRIDFUNCTION &X, INT ELEM,  VECTOR &STRESS){
//   FINITEELEMENTSPACE *FES = X.FESPACE();
//   ARRAY<INT> UDOFS;
//   CONST FINITEELEMENT *FE = FES->GETFE(ELEM);
//   CONST INT DOF = FE->GETDOF();
//   CONST INT DIM = FE->GETDIM();
//   CONST INT TDIM = DIM*(DIM+1)/2; // NUM. ENTRIES IN A SYMMETRIC TENSOR
	
//   DENSEMATRIX DSHAPE(DOF, DIM);
//   DENSEMATRIX GH(DIM, DIM),GRAD (DIM, DIM);
//   FES->GETELEMENTVDOFS(ELEM, UDOFS);
//   DENSEMATRIX LOC_DATA(DOF, DIM);
//   FOR (INT S=0 ; S<DIM ; S++)
//     {
//       ARRAY<INT> UDOFS_TMP(DOF);
//       UDOFS_TMP = 0.;
//       FOR(INT J=0 ; J<DOF ; J++){
// 	UDOFS_TMP[J] = UDOFS[J+DOF*S];}

//       VECTOR LOC_DATA_TMP;
//       X.GETSUBVECTOR(UDOFS_TMP, LOC_DATA_TMP);

//       FOR (INT J=0 ; J<DOF ; J++)
// 	LOC_DATA(J,S) = LOC_DATA_TMP(J);
//     }

//   DOUBLE W = T.WEIGHT() * IP.WEIGHT;
//   FE->CALCDSHAPE(IP, DSHAPE);
//   MULTATB(LOC_DATA, DSHAPE, GH);
//   MULT(GH, T.INVERSEJACOBIAN(), GRAD);
//   STRESS(0)=GRAD(0,0);
//   STRESS(1)=GRAD(1,1);
//   IF(DIM==2){
//     STRESS(2)=0.5*(GRAD(1,0)+GRAD(0,1));
//   }
//   ELSE IF(DIM==3){
//     STRESS(2)=GRAD(2,2);
//     STRESS(3)=0.5*(GRAD(1,0)+GRAD(0,1));
//     STRESS(4)=0.5*(GRAD(2,0)+GRAD(0,2));
//     STRESS(5)=0.5*(GRAD(2,1)+GRAD(1,2));
//   }
//   ELSE{
//     COUT<<"DIMENTION NOT SUPORTED"<<ENDL;}
// }

